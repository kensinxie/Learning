### 跨域Session共享问题

**跨域产生的条件**

- 使用xmlHttpRequest,即我们通常说的ajax请求

- 浏览器做了这个事

- 访问的域名不同，即访问的html页面是a域名下的，但内部js发送的ajax请求的目标地址却是b域名

以上三个条件缺一不可，尤其是第三个条件许多做移动端的同学可能都没有听过，因为移动端爽爽的用各种http请求狂发不同的域名，但是浏览器不允许我们这么做，为了一个词 安全



解决方法：

客户端：

![image-20210613134605700](项目问题.assets/image-20210613134605700.png)

服务端：

![image-20210613134732007](项目问题.assets/image-20210613134732007.png)



### Nginx反向代理

![image-20210614103022713](项目问题.assets/image-20210614103022713.png)



### RocketMQ

◆高性能，高并发，分布式消息中间件
◆典型应用场景：分布式事务，异步解耦

![概念模型](项目问题.assets/image-20210614144828749.png)

 

右侧是消费单体和消费组。

一个Topic可以被多个Broker管理。

MessageQueue 类似于ArrayBlockingQueue。



![部署模型](项目问题.assets/image-20210614145108127.png)

nameserber:类似于zookeeper一样，做服务发现使用。

broker、producer、consumer都需要去上面做注册。



![image-20210614170755844](项目问题.assets/image-20210614170755844.png)

以consumer group为单位做消息的管理。Producer只负责发送消息，而不关心消息是被谁消费的。

consumer group1（订单系统）中只能有一个consumer可以消费msg1。

consumer group2（日志系统）也可以有一个consumer去消费msg1。

broker会在消息上做不同的标记。



主从复制：

![image-20210614171311994](项目问题.assets/image-20210614171311994.png)

在broker1挂掉之后，nameserver会自动将slave竞选为主broker。并且通知所有的producer和consumer去broker2上进行操作。



主从之间可以分为 同步 和异步的同步方式。



设置consumer去订阅主题，当有消息时会自动调用该函数。真就是 观察者模式，也叫发布-订阅模式。

返回consumer_success即告诉消息队列，该消息被我消费了，不用再投放了。



### 分布式事务

![image-20210614171727760](项目问题.assets/image-20210614171727760.png)

在本地Spring事务和MySql的事务支持下，可以达到强一致性。

但是在分布式环境下，却只能牺牲一部分的一致性，以获得高可用性和分区特性。我们不要求强一致性，但要求最终一致。

即 基本可用性、软状态（中间过程存在不一致状态）和最终一致性。



### 如何防止超卖？

1、利用数据库自带排他锁，当减库存的时候，进位where判断，只有库存余量大于0的时候才进行进库存; update goods set num = num - 1 WHERE id = 1001 and num > 0; 

2、也可以自己实现乐观锁CAS（(Compare and swap)版本号机制。select version from goods WHERE id= 1001；update goods set num = num - 1, version = version + 1 WHERE id= 1001 AND num > 0 AND version = @version(上面查到的version);

### **服务器抗压思路**

1. 生成订单前，进行一系列的检验：是否还有库存（redis标志位缓存），是否重复下单（表单中隐藏域id），这些数据都可以缓存。
2. 在商品活动开始前进行预热，将对应商品的库存预先缓存在redis中。这样相较每次去数据库扣减库存更迅速、高效。
3. 使用消息队列，异步去扣减数据库的库存；（异步生成订单实际上是 假异步化，用户还是得在页面上等待返回，前端轮询查询异步订单状态）

  ### **怎么保证redis缓存和数据库的一致性**

有三种经典的缓存使用模式：https://xie.infoq.cn/article/1322475e05c11bd2aacd8bc73

- Cache-Aside Pattern 旁路缓存模式

- Read-Through/Write-through 读写穿透模式 

- Write-behind 异步缓存写入 数据库作为最后面的记账管家

### 日常开发中，我们一般使用的就是 Cache-Aside 模式。有些小伙伴可能会问， Cache-Aside 在写入请求的时候，为什么是删除缓存而不是更新缓存呢？

延时双删；删除缓存重试机制；读取 biglog 异步删除缓存。

在更新数据库时，先删除缓存，再去更新数据库，延时1s后，在删除缓存。更新后再次删除的原因是，防止在更新过程中有别人查询了，且更新到了缓存，造成脏数据。延迟1s的原因是，为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据。

### 秒杀项目中扣减库存过程

主要是采用了Write-behind模式，提前将库存加载进Redis中，使用Redis管理库存。在Redis扣减完库存后，再去异步更新数据库。而且采用事务型消息，将更新数据库、下订单合并在一个事务中，确保Redis和数据库的最终一致性。

事务型消息：transactionAsyncReduceStock，两段式提交。

先发送消息，但标记消息状态为prepared状态，不可被消费。


executeLocalTransaction：然后执行扣减库存、创建订单、更新redis的事务。一旦事务成功执行，则再次向MQ提交COMMIT_MESSAGE。否则，ROLLBACK_MESSAGE，对消息进行回滚。若长时间不响应结果，则checkLocalTransaction方法，检查事务执行状态，为了可以对事务进行跟踪，特别设置一个表stock_log。里面的状态位表示了此事务的状态。

