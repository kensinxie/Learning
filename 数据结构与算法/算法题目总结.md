![image-20210606152334061](算法题目总结.assets/image-20210606152334061.png)

刷题就是要 刻意练习。



## 数组、链表、跳表

数组和链表是最基本的两个 一维线性存储结构。二者的区别在于**底层实现方式**和是否能够做到**随机访问**。

跳表是一种典型的升维思想的体现，空间换时间。应用于Redis中的zset有序列表中。对标红黑树。

<img src="算法题目总结.assets/image-20210606160714896.png" alt="image-20210606160714896" style="zoom:50%;" />

### 数组题目：

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

![image-20210606161038318](算法题目总结.assets/image-20210606161038318.png)

最优 双指针法，哪边小就换哪边的。

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

![image-20210606161504858](算法题目总结.assets/image-20210606161504858.png)

index=0维护非零元素的界限；从前向后遍历，碰到非0元素，就与index交换。

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

![image-20210606161752811](算法题目总结.assets/image-20210606161752811.png)

dp[i]表示到达第i阶的方法数。dp[i]=dp[i-1]+dp[i-2]。初始：dp[1]=1,dp[2]=2。

也可以使用三个变量互相交换。

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

```java
class Solution {
    //[2..] 遍历nums，看是否存在target-nums[i]，存在即返回两个下标
    //否则就 将自己加入到map中
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{map.get(target-nums[i]),i};
            }
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```



#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

![image-20210606162129171](算法题目总结.assets/image-20210606162129171.png)

首先对数组排序 ，固定一个数字，另外两个数字 双指针，向中间移动。若和太大了，那右指针向左移动，反之亦然。

**注意：**答案中不可以包含重复的三元组。因此要保证固定的数字不能是重复的。

#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

![image-20210606174309093](算法题目总结.assets/image-20210606174309093.png)

```java
class Solution {
    //最后一位加1，若%10==0，则循环向前进位加一
    public int[] plusOne(int[] digits) {
        int n=digits.length;
        int idx=n-1,mod=0;
        while(idx>=0){
            mod=(digits[idx]+1)%10;
            if(mod==0){
                digits[idx]=0;
                idx--;
            }else{
                digits[idx]=mod;
                return digits;
            }
        }
        int[] res=new int[n+1];
        res[0]=1;
        return res;
    }
}
```



### 链表题目：

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

![image-20210606162601378](算法题目总结.assets/image-20210606162601378.png)

```java
class Solution {
    //[5]
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;//第一个节点要指向pre
        ListNode curr=head;
        while(curr!=null){
            ListNode temp=curr.next;
            curr.next=pre;
            pre=curr;
            curr=temp;
        }
        return pre;//最后返回pre
    }
}
```

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

![image-20210606163242975](算法题目总结.assets/image-20210606163242975.png)

```java
class Solution {
    //【c-1】经典基础题目 手动画图即可模拟
    public ListNode swapPairs(ListNode head) {
        ListNode dummyNode=new ListNode(0);
        dummyNode.next=head;
        ListNode pre=dummyNode;
        ListNode curr=head;
        while(curr!=null && curr.next!=null){   
            ListNode node2=curr.next;
            curr.next=node2.next;
            node2.next=curr;
            pre.next=node2;
            pre=curr;
            curr=curr.next;
        }
        return dummyNode.next;
    }
}
```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

![image-20210606164010368](算法题目总结.assets/image-20210606164010368.png)

```java
public class Solution {
    //1 week
    //s1 哈希表，碰到重复的键，说明重复了
    public boolean hasCycle(ListNode head) {
        Set<ListNode> set=new HashSet<>();
        while(head!=null){
            if(set.add(head)){
                head=head.next;
                continue;
            }else{
                return true;
            }
        }
        return false;
        
    }

    //s2 快慢指针，指针相遇则说明有环 o(1)的空间
    public boolean hasCycle(ListNode head) {
        if(head==null) return false;
        if(head.next==null) return false;
        ListNode slow=head;
        ListNode fast=head.next;

        while(fast!=null&&fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
            if(slow==fast){
                return true;
            }
        }
        return false;
    }
}
```

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

![image-20210606164817533](算法题目总结.assets/image-20210606164817533.png)

s1 哈希集合，检测到重复的那个就是环节点

#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

![image-20210606165021022](算法题目总结.assets/image-20210606165021022.png)

```java
class Solution {
    //[4] 链表的两个翻转、K个翻转，都需要一个dummyNode头结点和pre指针
    // 链表的翻转，批量操作，都需要pre 和curr(head)
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummyNode=new ListNode(0);
        dummyNode.next=head;
        ListNode pre=dummyNode;

        ListNode tail=pre;
        while(pre!=null){
            tail=pre;
            //判断是否有够k个
            for(int i=0;i<k;i++){
                tail=tail.next;
                if(tail==null){
                    return dummyNode.next;
                }
            }

            ListNode l[]=reverse(head,tail);
            head=l[0];
            tail=l[1];

            pre.next=head;
            pre=tail;
            head=pre.next;

        }
        
        return dummyNode.next;
    }

    public ListNode[] reverse(ListNode head, ListNode tail){//翻转head到tail之间的元素
        ListNode pre=tail.next;
        ListNode curr=head;
        while(pre!=tail){
            ListNode temp=curr.next;
            curr.next=pre;
            pre=curr;
            curr=temp;
        }
        return new ListNode[]{tail,head};
    }
}
```

#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

![image-20210606170338941](算法题目总结.assets/image-20210606170338941.png)

![image-20210606170357085](算法题目总结.assets/image-20210606170357085.png)

```java
class Solution {
    //[c-2] 双指针
    // l指向不重复的末尾（用于维护处理完的数组），r指向遍历的元素，
    public int removeDuplicates(int[] nums) {
        int l=0,r=1;
        int cnt=1;
        while(r<nums.length){
            if(nums[l]!=nums[r]){//碰到不相等的r，那就填充 不重复的那个数组
                nums[l+1]=nums[r];
                l++;r++;cnt++;
            }else{//相等那就r++继续向后找 不相等的元素
                r++;
            }
        }
        return cnt;
    }
}
```

#### [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

![image-20210606171034603](算法题目总结.assets/image-20210606171034603.png)

```java
class Solution {
    //1 week
    //s1 新数组，直接移入对应的下表位置处
    //s2 翻转三次
    public void rotate(int[] nums, int k) {
        myReverse(nums,0,nums.length-1);
        myReverse(nums,0,k%nums.length-1);
        myReverse(nums, k%nums.length, nums.length-1);

    }

    void myReverse(int[] nums,int i,int j){
        while(i<j){
            int temp=nums[i];
            nums[i]=nums[j];
            nums[j]=temp;
            i++;
            j--;
        }
    }
}
```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

![image-20210606173923915](算法题目总结.assets/image-20210606173923915.png)

```java
class Solution {
    //[c-1] 
    //dummyHead
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummyHead=new ListNode(0);
        ListNode curr=dummyHead;
        while(l1!=null && l2!=null){
            if(l1.val<=l2.val){
                curr.next=l1;
                l1=l1.next;
            }else{
                curr.next=l2;
                l2=l2.next;
            } 
            curr=curr.next;
        }
        if(l1!=null) curr.next=l1;
        if(l2!=null) curr.next=l2;
        return dummyHead.next;

    }
}
```

#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

![image-20210606174057349](算法题目总结.assets/image-20210606174057349.png)

```java
class Solution {
    //c-1 双指针
    //从后向前处理
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1=m-1,p2=n-1,index=m+n-1;
        while(p1>=0 && p2>=0){
            if(nums1[p1]<=nums2[p2]){
                nums1[index]=nums2[p2];
                index--;
                p2--;
            }else{
                nums1[index]=nums1[p1];
                index--;
                p1--;
            }
        }
        while(p1>=0){
            nums1[index]=nums1[p1];
            index--;
            p1--;
        }
        while(p2>=0){
            nums1[index]=nums2[p2];
            index--;
            p2--;
        }

    }
}
```

